{"abi":[{"type":"function","name":"balanceOf","inputs":[{"name":"account","type":"address","internalType":"address"},{"name":"id","type":"uint256","internalType":"uint256"}],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"balanceOfBatch","inputs":[{"name":"accounts","type":"address[]","internalType":"address[]"},{"name":"ids","type":"uint256[]","internalType":"uint256[]"}],"outputs":[{"name":"","type":"uint256[]","internalType":"uint256[]"}],"stateMutability":"view"},{"type":"function","name":"burnKey","inputs":[{"name":"rootKeyId","type":"uint256","internalType":"uint256"},{"name":"keyId","type":"uint256","internalType":"uint256"},{"name":"holder","type":"address","internalType":"address"},{"name":"amount","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"copyKey","inputs":[{"name":"rootKeyId","type":"uint256","internalType":"uint256"},{"name":"keyId","type":"uint256","internalType":"uint256"},{"name":"receiver","type":"address","internalType":"address"},{"name":"bind","type":"bool","internalType":"bool"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"createKey","inputs":[{"name":"rootKeyId","type":"uint256","internalType":"uint256"},{"name":"keyName","type":"bytes32","internalType":"bytes32"},{"name":"keyUri","type":"string","internalType":"string"},{"name":"receiver","type":"address","internalType":"address"},{"name":"bind","type":"bool","internalType":"bool"}],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"nonpayable"},{"type":"function","name":"createKeyRing","inputs":[{"name":"ringName","type":"bytes32","internalType":"bytes32"},{"name":"rootKeyName","type":"bytes32","internalType":"bytes32"},{"name":"keyUri","type":"string","internalType":"string"},{"name":"recipient","type":"address","internalType":"address"}],"outputs":[{"name":"","type":"uint256","internalType":"uint256"},{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"nonpayable"},{"type":"function","name":"getHolders","inputs":[{"name":"keyId","type":"uint256","internalType":"uint256"}],"outputs":[{"name":"","type":"address[]","internalType":"address[]"}],"stateMutability":"view"},{"type":"function","name":"getKeysForHolder","inputs":[{"name":"holder","type":"address","internalType":"address"}],"outputs":[{"name":"","type":"uint256[]","internalType":"uint256[]"}],"stateMutability":"view"},{"type":"function","name":"getRingInfo","inputs":[{"name":"ringId","type":"uint256","internalType":"uint256"}],"outputs":[{"name":"","type":"uint256","internalType":"uint256"},{"name":"","type":"bytes32","internalType":"bytes32"},{"name":"","type":"uint256","internalType":"uint256"},{"name":"","type":"uint256[]","internalType":"uint256[]"}],"stateMutability":"view"},{"type":"function","name":"getSoulboundAmount","inputs":[{"name":"account","type":"address","internalType":"address"},{"name":"keyId","type":"uint256","internalType":"uint256"}],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"hasKeyOrRoot","inputs":[{"name":"keyHolder","type":"address","internalType":"address"},{"name":"keyId","type":"uint256","internalType":"uint256"}],"outputs":[{"name":"","type":"bool","internalType":"bool"}],"stateMutability":"view"},{"type":"function","name":"inspectKey","inputs":[{"name":"keyId","type":"uint256","internalType":"uint256"}],"outputs":[{"name":"","type":"bool","internalType":"bool"},{"name":"","type":"bytes32","internalType":"bytes32"},{"name":"","type":"uint256","internalType":"uint256"},{"name":"","type":"bool","internalType":"bool"},{"name":"","type":"uint256[]","internalType":"uint256[]"}],"stateMutability":"view"},{"type":"function","name":"isApprovedForAll","inputs":[{"name":"account","type":"address","internalType":"address"},{"name":"operator","type":"address","internalType":"address"}],"outputs":[{"name":"","type":"bool","internalType":"bool"}],"stateMutability":"view"},{"type":"function","name":"isRootKey","inputs":[{"name":"keyId","type":"uint256","internalType":"uint256"}],"outputs":[{"name":"","type":"bool","internalType":"bool"}],"stateMutability":"view"},{"type":"function","name":"safeBatchTransferFrom","inputs":[{"name":"from","type":"address","internalType":"address"},{"name":"to","type":"address","internalType":"address"},{"name":"ids","type":"uint256[]","internalType":"uint256[]"},{"name":"values","type":"uint256[]","internalType":"uint256[]"},{"name":"data","type":"bytes","internalType":"bytes"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"safeTransferFrom","inputs":[{"name":"from","type":"address","internalType":"address"},{"name":"to","type":"address","internalType":"address"},{"name":"id","type":"uint256","internalType":"uint256"},{"name":"value","type":"uint256","internalType":"uint256"},{"name":"data","type":"bytes","internalType":"bytes"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"setApprovalForAll","inputs":[{"name":"operator","type":"address","internalType":"address"},{"name":"approved","type":"bool","internalType":"bool"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"soulbindKey","inputs":[{"name":"rootKeyId","type":"uint256","internalType":"uint256"},{"name":"keyHolder","type":"address","internalType":"address"},{"name":"keyId","type":"uint256","internalType":"uint256"},{"name":"amount","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"supportsInterface","inputs":[{"name":"interfaceId","type":"bytes4","internalType":"bytes4"}],"outputs":[{"name":"","type":"bool","internalType":"bool"}],"stateMutability":"view"},{"type":"function","name":"validateKeyRing","inputs":[{"name":"ringId","type":"uint256","internalType":"uint256"},{"name":"keys","type":"uint256[]","internalType":"uint256[]"},{"name":"allowRoot","type":"bool","internalType":"bool"}],"outputs":[{"name":"","type":"bool","internalType":"bool"}],"stateMutability":"view"},{"type":"event","name":"ApprovalForAll","inputs":[{"name":"account","type":"address","indexed":true,"internalType":"address"},{"name":"operator","type":"address","indexed":true,"internalType":"address"},{"name":"approved","type":"bool","indexed":false,"internalType":"bool"}],"anonymous":false},{"type":"event","name":"TransferBatch","inputs":[{"name":"operator","type":"address","indexed":true,"internalType":"address"},{"name":"from","type":"address","indexed":true,"internalType":"address"},{"name":"to","type":"address","indexed":true,"internalType":"address"},{"name":"ids","type":"uint256[]","indexed":false,"internalType":"uint256[]"},{"name":"values","type":"uint256[]","indexed":false,"internalType":"uint256[]"}],"anonymous":false},{"type":"event","name":"TransferSingle","inputs":[{"name":"operator","type":"address","indexed":true,"internalType":"address"},{"name":"from","type":"address","indexed":true,"internalType":"address"},{"name":"to","type":"address","indexed":true,"internalType":"address"},{"name":"id","type":"uint256","indexed":false,"internalType":"uint256"},{"name":"value","type":"uint256","indexed":false,"internalType":"uint256"}],"anonymous":false},{"type":"event","name":"URI","inputs":[{"name":"value","type":"string","indexed":false,"internalType":"string"},{"name":"id","type":"uint256","indexed":true,"internalType":"uint256"}],"anonymous":false},{"type":"event","name":"keyBurned","inputs":[{"name":"operator","type":"address","indexed":false,"internalType":"address"},{"name":"ringId","type":"uint256","indexed":false,"internalType":"uint256"},{"name":"keyId","type":"uint256","indexed":false,"internalType":"uint256"},{"name":"target","type":"address","indexed":false,"internalType":"address"},{"name":"amount","type":"uint256","indexed":false,"internalType":"uint256"}],"anonymous":false},{"type":"event","name":"keyMinted","inputs":[{"name":"operator","type":"address","indexed":false,"internalType":"address"},{"name":"ringId","type":"uint256","indexed":false,"internalType":"uint256"},{"name":"keyId","type":"uint256","indexed":false,"internalType":"uint256"},{"name":"receiver","type":"address","indexed":false,"internalType":"address"}],"anonymous":false},{"type":"event","name":"keyRingCreated","inputs":[{"name":"operator","type":"address","indexed":false,"internalType":"address"},{"name":"ringId","type":"uint256","indexed":false,"internalType":"uint256"},{"name":"ringName","type":"bytes32","indexed":false,"internalType":"bytes32"},{"name":"recipient","type":"address","indexed":false,"internalType":"address"}],"anonymous":false},{"type":"event","name":"setSoulboundKeyAmount","inputs":[{"name":"operator","type":"address","indexed":false,"internalType":"address"},{"name":"keyHolder","type":"address","indexed":false,"internalType":"address"},{"name":"keyId","type":"uint256","indexed":false,"internalType":"uint256"},{"name":"amount","type":"uint256","indexed":false,"internalType":"uint256"}],"anonymous":false}],"bytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"deployedBytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"methodIdentifiers":{"balanceOf(address,uint256)":"00fdd58e","balanceOfBatch(address[],uint256[])":"4e1273f4","burnKey(uint256,uint256,address,uint256)":"11511668","copyKey(uint256,uint256,address,bool)":"218fa8e6","createKey(uint256,bytes32,string,address,bool)":"18c28027","createKeyRing(bytes32,bytes32,string,address)":"f01bda63","getHolders(uint256)":"92707869","getKeysForHolder(address)":"039cf5fb","getRingInfo(uint256)":"4dfdf2c8","getSoulboundAmount(address,uint256)":"102e6c66","hasKeyOrRoot(address,uint256)":"02dcd8c1","inspectKey(uint256)":"88ecda52","isApprovedForAll(address,address)":"e985e9c5","isRootKey(uint256)":"d2bd0fad","safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)":"2eb2c2d6","safeTransferFrom(address,address,uint256,uint256,bytes)":"f242432a","setApprovalForAll(address,bool)":"a22cb465","soulbindKey(uint256,address,uint256,uint256)":"6d7012fa","supportsInterface(bytes4)":"01ffc9a7","validateKeyRing(uint256,uint256[],bool)":"53a81ee1"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ringId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"keyId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"keyBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ringId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"keyId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"keyMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ringId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"ringName\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"keyRingCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"keyHolder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"keyId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setSoulboundKeyAmount\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rootKeyId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"keyId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnKey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rootKeyId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"keyId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"bind\",\"type\":\"bool\"}],\"name\":\"copyKey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rootKeyId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"keyName\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"keyUri\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"bind\",\"type\":\"bool\"}],\"name\":\"createKey\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ringName\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"rootKeyName\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"keyUri\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"createKeyRing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"keyId\",\"type\":\"uint256\"}],\"name\":\"getHolders\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getKeysForHolder\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ringId\",\"type\":\"uint256\"}],\"name\":\"getRingInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"keyId\",\"type\":\"uint256\"}],\"name\":\"getSoulboundAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"keyHolder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"keyId\",\"type\":\"uint256\"}],\"name\":\"hasKeyOrRoot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"keyId\",\"type\":\"uint256\"}],\"name\":\"inspectKey\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"keyId\",\"type\":\"uint256\"}],\"name\":\"isRootKey\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rootKeyId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"keyHolder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"keyId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"soulbindKey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ringId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"keys\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"allowRoot\",\"type\":\"bool\"}],\"name\":\"validateKeyRing\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"ApprovalForAll(address,address,bool)\":{\"details\":\"Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to `approved`.\"},\"TransferBatch(address,address,address,uint256[],uint256[])\":{\"details\":\"Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all transfers.\"},\"TransferSingle(address,address,address,uint256,uint256)\":{\"details\":\"Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\"},\"URI(string,uint256)\":{\"details\":\"Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI. If an {URI} event was emitted for `id`, the standard https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value returned by {IERC1155MetadataURI-uri}.\"},\"keyBurned(address,uint256,uint256,address,uint256)\":{\"params\":{\"amount\":\"the number of keys burned in the operation.\",\"keyId\":\"the key ID that was burned. \",\"operator\":\"the root key holder requesting the burn. \",\"ringId\":\"the ring ID they are burning from.\",\"target\":\"the address of the wallet that had keys burned. \"}},\"keyMinted(address,uint256,uint256,address)\":{\"params\":{\"keyId\":\"the key ID that was minted by the operator. \",\"operator\":\"the creator of the ring key.\",\"receiver\":\"the receiving wallet address where the keyId was deposited.\",\"ringId\":\"the key ring ID they are creating the key on. \"}},\"keyRingCreated(address,uint256,bytes32,address)\":{\"params\":{\"operator\":\"the message sender and creator of the key ring.\",\"recipient\":\"the address of the root key recipient\",\"ringId\":\"the resulting id of the new key ring. \",\"ringName\":\"the ring's human readable name, encoded as a bytes32.\"}},\"setSoulboundKeyAmount(address,address,uint256,uint256)\":{\"params\":{\"amount\":\"the number of tokens this address must hold\",\"keyHolder\":\"the address we are changing the binding for\",\"keyId\":\"the Id we are setting the binding state for\",\"operator\":\"the root key holder that is changing the soulbinding \"}}},\"kind\":\"dev\",\"methods\":{\"balanceOf(address,uint256)\":{\"details\":\"Returns the value of tokens of token type `id` owned by `account`. Requirements: - `account` cannot be the zero address.\"},\"balanceOfBatch(address[],uint256[])\":{\"details\":\"xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}. Requirements: - `accounts` and `ids` must have the same length.\"},\"burnKey(uint256,uint256,address,uint256)\":{\"params\":{\"amount\":\"the number of keys you want to burn.\",\"holder\":\"address of the holder you want to burn from.\",\"keyId\":\"id of the key you want to burn.\",\"rootKeyId\":\"root key for the associated ring.\"}},\"copyKey(uint256,uint256,address,bool)\":{\"params\":{\"bind\":\"true if you want to bind the key to the receiver. \",\"keyId\":\"key ID the message sender wishes to copy.\",\"receiver\":\"addresses of the receivers for the copied key.\",\"rootKeyId\":\"root key to be used for this operation.\"}},\"createKey(uint256,bytes32,string,address,bool)\":{\"params\":{\"bind\":\"true if you want to bind the key to the receiver.\",\"keyName\":\"An alias that you want to give the key.\",\"keyUri\":\"The metadata URI for the newly created key.\",\"receiver\":\"address you want to receive the ring key. \",\"rootKeyId\":\"The root key the sender is attempting to operate to create new keys.\"},\"returns\":{\"_0\":\"the ID of the key that was created\"}},\"createKeyRing(bytes32,bytes32,string,address)\":{\"params\":{\"keyUri\":\"The metadata URI for the new root key.\",\"recipient\":\"The address to receive the root key for this key ring.\",\"ringName\":\"A string defining the name of the key ring encoded as bytes32.\",\"rootKeyName\":\"A string denoting a human readable name of the root key. \"},\"returns\":{\"_0\":\"the key ring ID that was created\",\"_1\":\"the root key ID that was created\"}},\"getHolders(uint256)\":{\"params\":{\"keyId\":\"the key ID to look for.\"},\"returns\":{\"_0\":\"an array of addresses that hold that key.\"}},\"getKeysForHolder(address)\":{\"params\":{\"holder\":\"the address of the key holder you want to see.\"},\"returns\":{\"_0\":\"an array of key IDs held by the user.\"}},\"getRingInfo(uint256)\":{\"params\":{\"ringId\":\"The ID of the ring to inspect.\"},\"returns\":{\"_0\":\"The ring ID back as verification.\",\"_1\":\"The human readable name for the ring.\",\"_2\":\"The root key ID for the ring.\",\"_3\":\"The list of keys for the ring.\"}},\"getSoulboundAmount(address,uint256)\":{\"params\":{\"account\":\"The wallet address you want the binding amount for. \",\"keyId\":\"The key id you want the soulbound amount for. \"},\"returns\":{\"_0\":\"the soulbound token requirement for that wallet and key id.\"}},\"hasKeyOrRoot(address,uint256)\":{\"params\":{\"keyHolder\":\"the address of the keyholder to check.\",\"keyId\":\"the key you want to check they are holding.\"},\"returns\":{\"_0\":\"true if keyHolder has either keyId, or the keyId's associated root key.\"}},\"inspectKey(uint256)\":{\"returns\":{\"_0\":\"true if the key is a valid key\",\"_1\":\"alias of the key \",\"_2\":\"the ring id of the key (only if its considered valid)\",\"_3\":\"true if the key is a root key\",\"_4\":\"the keys associated with the given ring \"}},\"isApprovedForAll(address,address)\":{\"details\":\"Returns true if `operator` is approved to transfer ``account``'s tokens. See {setApprovalForAll}.\"},\"isRootKey(uint256)\":{\"params\":{\"keyId\":\"the key id in question\"},\"returns\":{\"_0\":\"true if the key Id is the root key of it's associated key ring \"}},\"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\":{\"details\":\"xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}. WARNING: This function can potentially allow a reentrancy attack when transferring tokens to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver. Ensure to follow the checks-effects-interactions pattern and consider employing reentrancy guards when interacting with untrusted contracts. Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments. Requirements: - `ids` and `values` must have the same length. - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value.\"},\"safeTransferFrom(address,address,uint256,uint256,bytes)\":{\"details\":\"Transfers a `value` amount of tokens of type `id` from `from` to `to`. WARNING: This function can potentially allow a reentrancy attack when transferring tokens to an untrusted contract, when invoking {onERC1155Received} on the receiver. Ensure to follow the checks-effects-interactions pattern and consider employing reentrancy guards when interacting with untrusted contracts. Emits a {TransferSingle} event. Requirements: - `to` cannot be the zero address. - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}. - `from` must have a balance of tokens of type `id` of at least `value` amount. - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value.\"},\"setApprovalForAll(address,bool)\":{\"details\":\"Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`, Emits an {ApprovalForAll} event. Requirements: - `operator` cannot be the caller.\"},\"soulbindKey(uint256,address,uint256,uint256)\":{\"params\":{\"amount\":\"the amount of keys to bind to the holder.\",\"keyHolder\":\"the address to bind the key to.\",\"keyId\":\"the keyId they want to bind.\",\"rootKeyId\":\"the operator's root key.\"}},\"supportsInterface(bytes4)\":{\"details\":\"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.\"},\"validateKeyRing(uint256,uint256[],bool)\":{\"params\":{\"allowRoot\":\"true if providing the ring's root key as input is acceptable\",\"keys\":\"the supposed keys that belong to the ring\",\"ringId\":\"the ring ID you want to validate against\"},\"returns\":{\"_0\":\"true if valid, or will otherwise revert.\"}}},\"version\":1},\"userdoc\":{\"events\":{\"keyBurned(address,uint256,uint256,address,uint256)\":{\"notice\":\"keyBurned This event is emitted when a key is burned by the root key holder. \"},\"keyMinted(address,uint256,uint256,address)\":{\"notice\":\"keyMinted This event is emitted when a key is minted. This event is also emitted when a root key is minted upon ring creation. The operator will always hold the root key for the ringId.\"},\"keyRingCreated(address,uint256,bytes32,address)\":{\"notice\":\"keyRingCreated  This event is emitted when a key ring is created and a root key is minted.\"},\"setSoulboundKeyAmount(address,address,uint256,uint256)\":{\"notice\":\"setSoulboundKeyAmount This event fires when the state of a soulbind key is set.\"}},\"kind\":\"user\",\"methods\":{\"burnKey(uint256,uint256,address,uint256)\":{\"notice\":\"burnKey The root key holder can call this method if they want to revoke a key from a holder. This code will panic if:  - The caller doesn't hold the root key.  - The key id is not on the same ring as the root key.  - The target holder doesn't have sufficient keys to burn.\"},\"copyKey(uint256,uint256,address,bool)\":{\"notice\":\"copyKey The root key holder can call this method if they have an existing key they want to copy. This allows multiple addresses to hold the same role, share a set of benefits, or enables the root key holder to restore the role for someone who lost their seed or access to their wallet. This method can only be invoked with a root key, which is held by the message sender. The key they want to copy also must be associated with the ring bound to the root key used. This code will panic if:  - the caller doesn't hold the root key  - the provided key ID isn't associated with the root key's key ring\"},\"createKey(uint256,bytes32,string,address,bool)\":{\"notice\":\"createKey The holder of a root key can use it to generate brand new keys  and add them to the root key's key ring, sending it to the  destination wallets. This code will panic if:  - the caller doesn't hold the declared root key\"},\"createKeyRing(bytes32,bytes32,string,address)\":{\"notice\":\"createKeyRing Calling this function will create a key ring with a name, mint the first root key, and give it to the desginated receiver.\"},\"getHolders(uint256)\":{\"notice\":\"getHolders This method will return the addresses that hold a particular keyId.\"},\"getKeysForHolder(address)\":{\"notice\":\"getKeysForHolder This method will return the IDs of the keys held by the given address.\"},\"getRingInfo(uint256)\":{\"notice\":\"getRingInfo() Given a ring, provides ring metadata back.\"},\"getSoulboundAmount(address,uint256)\":{\"notice\":\"getSoulboundAmount  Returns the number of keys a given holder must maintain when sending the associated key ID out of their address.\"},\"hasKeyOrRoot(address,uint256)\":{\"notice\":\"hasKeyOrRoot Determines if the given address holders either the key specified, or the ring's root key. This is used by contracts to enable root-key escalation, and prevents the need for root key holders to hold every key to operate as an admin.\"},\"inspectKey(uint256)\":{\"notice\":\"inspectKey   Takes a key id and inspects it. \"},\"isRootKey(uint256)\":{\"notice\":\"isRootKey\"},\"soulbindKey(uint256,address,uint256,uint256)\":{\"notice\":\"soulbindKey This method can be called by a root key holder to make a key soulbound to a specific address. When soulbinding a key, it is not required that the current target address hold that key. The amount set ensures that when sending a key of a specific type, that they hold at least the amount that is bound to them. This code will panic if:  - the caller doesn't have the root key  - the target keyId doesn't exist in the ring\"},\"validateKeyRing(uint256,uint256[],bool)\":{\"notice\":\"validateKeyRing Contracts can call this method to determine if a set of keys belong to the same ring. This is used as a validation method and will *revert* if the keys do not belong to the same ring. This is extremely useful when taking a set of keys and ensuring each is part of the same ring first. You can use allowRoot to enable cases were passing in the root key for validation is acceptable. Setting it to false enables you to easily detect if one of the keys provided is the root key. Remember, this method will revert also based on allowRoot semantics. \"}},\"notice\":\"Locksmith  This contract has a single responsiblity: managing the lifecycle of keys. The Locksmith is an ERC1155 contract that can mint, burn, and bind permissions to owners. Users can permissionlessly mint and manage a collection of NFTs known as a \\\"key ring.\\\" Each key ring has a root key, which gives the holder permissions to mint, burn, and soulbind/unbind any other key that belongs to their ring to any address at any time. In effect, the key ring acts as an onchain access control list. The keys can be sent, delegated, and dynamically bound to any actor for any amount of time - including only for a part of a single transaction. \",\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/interfaces/ILocksmith.sol\":\"ILocksmith\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":20000},\"remappings\":[\":@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\"]},\"sources\":{\"lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol\":{\"keccak256\":\"0x6caffc9cfdc623eca9f87a686071708af5d5c17454d65022843fdddbc53c0cce\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://ecf8c7ed1f8ff443c181f64496ae380ee02e61dcd2ed120e1e997837a926f182\",\"dweb:/ipfs/QmWASYTrZPF2MrcpC3EBmxx6RgtZ5Fr4jwrsmB7ZF7qhDC\"]},\"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\":{\"keccak256\":\"0x4296879f55019b23e135000eb36896057e7101fb7fb859c5ef690cf14643757b\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://87b3541437c8c443ccd36795e56a338ed12855eec17f8da624511b8d1a7e14df\",\"dweb:/ipfs/QmeJQCtZrQjtJLr6u7ZHWeH3pBnjtLWzvRrKViAi7UZqxL\"]},\"src/interfaces/ILocksmith.sol\":{\"keccak256\":\"0xa4e657bdb544cb89456103e81f9c5863ed488afa0c9a9d40c98605beba0aceba\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://fa47405ddd95fe9d5419ebaba58fb34aa621e2cf6b406e03e3e68ca407619e5d\",\"dweb:/ipfs/QmfM4vWuiWY1iRPV2qgeqkyYiSNLAqyRoDRtvqdZyjYKcD\"]}},\"version\":1}","metadata":{"compiler":{"version":"0.8.23+commit.f704f362"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"address","name":"account","type":"address","indexed":true},{"internalType":"address","name":"operator","type":"address","indexed":true},{"internalType":"bool","name":"approved","type":"bool","indexed":false}],"type":"event","name":"ApprovalForAll","anonymous":false},{"inputs":[{"internalType":"address","name":"operator","type":"address","indexed":true},{"internalType":"address","name":"from","type":"address","indexed":true},{"internalType":"address","name":"to","type":"address","indexed":true},{"internalType":"uint256[]","name":"ids","type":"uint256[]","indexed":false},{"internalType":"uint256[]","name":"values","type":"uint256[]","indexed":false}],"type":"event","name":"TransferBatch","anonymous":false},{"inputs":[{"internalType":"address","name":"operator","type":"address","indexed":true},{"internalType":"address","name":"from","type":"address","indexed":true},{"internalType":"address","name":"to","type":"address","indexed":true},{"internalType":"uint256","name":"id","type":"uint256","indexed":false},{"internalType":"uint256","name":"value","type":"uint256","indexed":false}],"type":"event","name":"TransferSingle","anonymous":false},{"inputs":[{"internalType":"string","name":"value","type":"string","indexed":false},{"internalType":"uint256","name":"id","type":"uint256","indexed":true}],"type":"event","name":"URI","anonymous":false},{"inputs":[{"internalType":"address","name":"operator","type":"address","indexed":false},{"internalType":"uint256","name":"ringId","type":"uint256","indexed":false},{"internalType":"uint256","name":"keyId","type":"uint256","indexed":false},{"internalType":"address","name":"target","type":"address","indexed":false},{"internalType":"uint256","name":"amount","type":"uint256","indexed":false}],"type":"event","name":"keyBurned","anonymous":false},{"inputs":[{"internalType":"address","name":"operator","type":"address","indexed":false},{"internalType":"uint256","name":"ringId","type":"uint256","indexed":false},{"internalType":"uint256","name":"keyId","type":"uint256","indexed":false},{"internalType":"address","name":"receiver","type":"address","indexed":false}],"type":"event","name":"keyMinted","anonymous":false},{"inputs":[{"internalType":"address","name":"operator","type":"address","indexed":false},{"internalType":"uint256","name":"ringId","type":"uint256","indexed":false},{"internalType":"bytes32","name":"ringName","type":"bytes32","indexed":false},{"internalType":"address","name":"recipient","type":"address","indexed":false}],"type":"event","name":"keyRingCreated","anonymous":false},{"inputs":[{"internalType":"address","name":"operator","type":"address","indexed":false},{"internalType":"address","name":"keyHolder","type":"address","indexed":false},{"internalType":"uint256","name":"keyId","type":"uint256","indexed":false},{"internalType":"uint256","name":"amount","type":"uint256","indexed":false}],"type":"event","name":"setSoulboundKeyAmount","anonymous":false},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"id","type":"uint256"}],"stateMutability":"view","type":"function","name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[{"internalType":"address[]","name":"accounts","type":"address[]"},{"internalType":"uint256[]","name":"ids","type":"uint256[]"}],"stateMutability":"view","type":"function","name":"balanceOfBatch","outputs":[{"internalType":"uint256[]","name":"","type":"uint256[]"}]},{"inputs":[{"internalType":"uint256","name":"rootKeyId","type":"uint256"},{"internalType":"uint256","name":"keyId","type":"uint256"},{"internalType":"address","name":"holder","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"stateMutability":"nonpayable","type":"function","name":"burnKey"},{"inputs":[{"internalType":"uint256","name":"rootKeyId","type":"uint256"},{"internalType":"uint256","name":"keyId","type":"uint256"},{"internalType":"address","name":"receiver","type":"address"},{"internalType":"bool","name":"bind","type":"bool"}],"stateMutability":"nonpayable","type":"function","name":"copyKey"},{"inputs":[{"internalType":"uint256","name":"rootKeyId","type":"uint256"},{"internalType":"bytes32","name":"keyName","type":"bytes32"},{"internalType":"string","name":"keyUri","type":"string"},{"internalType":"address","name":"receiver","type":"address"},{"internalType":"bool","name":"bind","type":"bool"}],"stateMutability":"nonpayable","type":"function","name":"createKey","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[{"internalType":"bytes32","name":"ringName","type":"bytes32"},{"internalType":"bytes32","name":"rootKeyName","type":"bytes32"},{"internalType":"string","name":"keyUri","type":"string"},{"internalType":"address","name":"recipient","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"createKeyRing","outputs":[{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[{"internalType":"uint256","name":"keyId","type":"uint256"}],"stateMutability":"view","type":"function","name":"getHolders","outputs":[{"internalType":"address[]","name":"","type":"address[]"}]},{"inputs":[{"internalType":"address","name":"holder","type":"address"}],"stateMutability":"view","type":"function","name":"getKeysForHolder","outputs":[{"internalType":"uint256[]","name":"","type":"uint256[]"}]},{"inputs":[{"internalType":"uint256","name":"ringId","type":"uint256"}],"stateMutability":"view","type":"function","name":"getRingInfo","outputs":[{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"bytes32","name":"","type":"bytes32"},{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"uint256[]","name":"","type":"uint256[]"}]},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"keyId","type":"uint256"}],"stateMutability":"view","type":"function","name":"getSoulboundAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[{"internalType":"address","name":"keyHolder","type":"address"},{"internalType":"uint256","name":"keyId","type":"uint256"}],"stateMutability":"view","type":"function","name":"hasKeyOrRoot","outputs":[{"internalType":"bool","name":"","type":"bool"}]},{"inputs":[{"internalType":"uint256","name":"keyId","type":"uint256"}],"stateMutability":"view","type":"function","name":"inspectKey","outputs":[{"internalType":"bool","name":"","type":"bool"},{"internalType":"bytes32","name":"","type":"bytes32"},{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"bool","name":"","type":"bool"},{"internalType":"uint256[]","name":"","type":"uint256[]"}]},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"address","name":"operator","type":"address"}],"stateMutability":"view","type":"function","name":"isApprovedForAll","outputs":[{"internalType":"bool","name":"","type":"bool"}]},{"inputs":[{"internalType":"uint256","name":"keyId","type":"uint256"}],"stateMutability":"view","type":"function","name":"isRootKey","outputs":[{"internalType":"bool","name":"","type":"bool"}]},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256[]","name":"ids","type":"uint256[]"},{"internalType":"uint256[]","name":"values","type":"uint256[]"},{"internalType":"bytes","name":"data","type":"bytes"}],"stateMutability":"nonpayable","type":"function","name":"safeBatchTransferFrom"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"id","type":"uint256"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"}],"stateMutability":"nonpayable","type":"function","name":"safeTransferFrom"},{"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bool","name":"approved","type":"bool"}],"stateMutability":"nonpayable","type":"function","name":"setApprovalForAll"},{"inputs":[{"internalType":"uint256","name":"rootKeyId","type":"uint256"},{"internalType":"address","name":"keyHolder","type":"address"},{"internalType":"uint256","name":"keyId","type":"uint256"},{"internalType":"uint256","name":"amount","type":"uint256"}],"stateMutability":"nonpayable","type":"function","name":"soulbindKey"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"stateMutability":"view","type":"function","name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}]},{"inputs":[{"internalType":"uint256","name":"ringId","type":"uint256"},{"internalType":"uint256[]","name":"keys","type":"uint256[]"},{"internalType":"bool","name":"allowRoot","type":"bool"}],"stateMutability":"view","type":"function","name":"validateKeyRing","outputs":[{"internalType":"bool","name":"","type":"bool"}]}],"devdoc":{"kind":"dev","methods":{"balanceOf(address,uint256)":{"details":"Returns the value of tokens of token type `id` owned by `account`. Requirements: - `account` cannot be the zero address."},"balanceOfBatch(address[],uint256[])":{"details":"xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}. Requirements: - `accounts` and `ids` must have the same length."},"burnKey(uint256,uint256,address,uint256)":{"params":{"amount":"the number of keys you want to burn.","holder":"address of the holder you want to burn from.","keyId":"id of the key you want to burn.","rootKeyId":"root key for the associated ring."}},"copyKey(uint256,uint256,address,bool)":{"params":{"bind":"true if you want to bind the key to the receiver. ","keyId":"key ID the message sender wishes to copy.","receiver":"addresses of the receivers for the copied key.","rootKeyId":"root key to be used for this operation."}},"createKey(uint256,bytes32,string,address,bool)":{"params":{"bind":"true if you want to bind the key to the receiver.","keyName":"An alias that you want to give the key.","keyUri":"The metadata URI for the newly created key.","receiver":"address you want to receive the ring key. ","rootKeyId":"The root key the sender is attempting to operate to create new keys."},"returns":{"_0":"the ID of the key that was created"}},"createKeyRing(bytes32,bytes32,string,address)":{"params":{"keyUri":"The metadata URI for the new root key.","recipient":"The address to receive the root key for this key ring.","ringName":"A string defining the name of the key ring encoded as bytes32.","rootKeyName":"A string denoting a human readable name of the root key. "},"returns":{"_0":"the key ring ID that was created","_1":"the root key ID that was created"}},"getHolders(uint256)":{"params":{"keyId":"the key ID to look for."},"returns":{"_0":"an array of addresses that hold that key."}},"getKeysForHolder(address)":{"params":{"holder":"the address of the key holder you want to see."},"returns":{"_0":"an array of key IDs held by the user."}},"getRingInfo(uint256)":{"params":{"ringId":"The ID of the ring to inspect."},"returns":{"_0":"The ring ID back as verification.","_1":"The human readable name for the ring.","_2":"The root key ID for the ring.","_3":"The list of keys for the ring."}},"getSoulboundAmount(address,uint256)":{"params":{"account":"The wallet address you want the binding amount for. ","keyId":"The key id you want the soulbound amount for. "},"returns":{"_0":"the soulbound token requirement for that wallet and key id."}},"hasKeyOrRoot(address,uint256)":{"params":{"keyHolder":"the address of the keyholder to check.","keyId":"the key you want to check they are holding."},"returns":{"_0":"true if keyHolder has either keyId, or the keyId's associated root key."}},"inspectKey(uint256)":{"returns":{"_0":"true if the key is a valid key","_1":"alias of the key ","_2":"the ring id of the key (only if its considered valid)","_3":"true if the key is a root key","_4":"the keys associated with the given ring "}},"isApprovedForAll(address,address)":{"details":"Returns true if `operator` is approved to transfer ``account``'s tokens. See {setApprovalForAll}."},"isRootKey(uint256)":{"params":{"keyId":"the key id in question"},"returns":{"_0":"true if the key Id is the root key of it's associated key ring "}},"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)":{"details":"xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}. WARNING: This function can potentially allow a reentrancy attack when transferring tokens to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver. Ensure to follow the checks-effects-interactions pattern and consider employing reentrancy guards when interacting with untrusted contracts. Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments. Requirements: - `ids` and `values` must have the same length. - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value."},"safeTransferFrom(address,address,uint256,uint256,bytes)":{"details":"Transfers a `value` amount of tokens of type `id` from `from` to `to`. WARNING: This function can potentially allow a reentrancy attack when transferring tokens to an untrusted contract, when invoking {onERC1155Received} on the receiver. Ensure to follow the checks-effects-interactions pattern and consider employing reentrancy guards when interacting with untrusted contracts. Emits a {TransferSingle} event. Requirements: - `to` cannot be the zero address. - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}. - `from` must have a balance of tokens of type `id` of at least `value` amount. - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value."},"setApprovalForAll(address,bool)":{"details":"Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`, Emits an {ApprovalForAll} event. Requirements: - `operator` cannot be the caller."},"soulbindKey(uint256,address,uint256,uint256)":{"params":{"amount":"the amount of keys to bind to the holder.","keyHolder":"the address to bind the key to.","keyId":"the keyId they want to bind.","rootKeyId":"the operator's root key."}},"supportsInterface(bytes4)":{"details":"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."},"validateKeyRing(uint256,uint256[],bool)":{"params":{"allowRoot":"true if providing the ring's root key as input is acceptable","keys":"the supposed keys that belong to the ring","ringId":"the ring ID you want to validate against"},"returns":{"_0":"true if valid, or will otherwise revert."}}},"version":1},"userdoc":{"kind":"user","methods":{"burnKey(uint256,uint256,address,uint256)":{"notice":"burnKey The root key holder can call this method if they want to revoke a key from a holder. This code will panic if:  - The caller doesn't hold the root key.  - The key id is not on the same ring as the root key.  - The target holder doesn't have sufficient keys to burn."},"copyKey(uint256,uint256,address,bool)":{"notice":"copyKey The root key holder can call this method if they have an existing key they want to copy. This allows multiple addresses to hold the same role, share a set of benefits, or enables the root key holder to restore the role for someone who lost their seed or access to their wallet. This method can only be invoked with a root key, which is held by the message sender. The key they want to copy also must be associated with the ring bound to the root key used. This code will panic if:  - the caller doesn't hold the root key  - the provided key ID isn't associated with the root key's key ring"},"createKey(uint256,bytes32,string,address,bool)":{"notice":"createKey The holder of a root key can use it to generate brand new keys  and add them to the root key's key ring, sending it to the  destination wallets. This code will panic if:  - the caller doesn't hold the declared root key"},"createKeyRing(bytes32,bytes32,string,address)":{"notice":"createKeyRing Calling this function will create a key ring with a name, mint the first root key, and give it to the desginated receiver."},"getHolders(uint256)":{"notice":"getHolders This method will return the addresses that hold a particular keyId."},"getKeysForHolder(address)":{"notice":"getKeysForHolder This method will return the IDs of the keys held by the given address."},"getRingInfo(uint256)":{"notice":"getRingInfo() Given a ring, provides ring metadata back."},"getSoulboundAmount(address,uint256)":{"notice":"getSoulboundAmount  Returns the number of keys a given holder must maintain when sending the associated key ID out of their address."},"hasKeyOrRoot(address,uint256)":{"notice":"hasKeyOrRoot Determines if the given address holders either the key specified, or the ring's root key. This is used by contracts to enable root-key escalation, and prevents the need for root key holders to hold every key to operate as an admin."},"inspectKey(uint256)":{"notice":"inspectKey   Takes a key id and inspects it. "},"isRootKey(uint256)":{"notice":"isRootKey"},"soulbindKey(uint256,address,uint256,uint256)":{"notice":"soulbindKey This method can be called by a root key holder to make a key soulbound to a specific address. When soulbinding a key, it is not required that the current target address hold that key. The amount set ensures that when sending a key of a specific type, that they hold at least the amount that is bound to them. This code will panic if:  - the caller doesn't have the root key  - the target keyId doesn't exist in the ring"},"validateKeyRing(uint256,uint256[],bool)":{"notice":"validateKeyRing Contracts can call this method to determine if a set of keys belong to the same ring. This is used as a validation method and will *revert* if the keys do not belong to the same ring. This is extremely useful when taking a set of keys and ensuring each is part of the same ring first. You can use allowRoot to enable cases were passing in the root key for validation is acceptable. Setting it to false enables you to easily detect if one of the keys provided is the root key. Remember, this method will revert also based on allowRoot semantics. "}},"version":1}},"settings":{"remappings":["@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/","ds-test/=lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","forge-std/=lib/forge-std/src/","openzeppelin-contracts/=lib/openzeppelin-contracts/"],"optimizer":{"enabled":true,"runs":20000},"metadata":{"bytecodeHash":"ipfs"},"compilationTarget":{"src/interfaces/ILocksmith.sol":"ILocksmith"},"libraries":{}},"sources":{"lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol":{"keccak256":"0x6caffc9cfdc623eca9f87a686071708af5d5c17454d65022843fdddbc53c0cce","urls":["bzz-raw://ecf8c7ed1f8ff443c181f64496ae380ee02e61dcd2ed120e1e997837a926f182","dweb:/ipfs/QmWASYTrZPF2MrcpC3EBmxx6RgtZ5Fr4jwrsmB7ZF7qhDC"],"license":"MIT"},"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol":{"keccak256":"0x4296879f55019b23e135000eb36896057e7101fb7fb859c5ef690cf14643757b","urls":["bzz-raw://87b3541437c8c443ccd36795e56a338ed12855eec17f8da624511b8d1a7e14df","dweb:/ipfs/QmeJQCtZrQjtJLr6u7ZHWeH3pBnjtLWzvRrKViAi7UZqxL"],"license":"MIT"},"src/interfaces/ILocksmith.sol":{"keccak256":"0xa4e657bdb544cb89456103e81f9c5863ed488afa0c9a9d40c98605beba0aceba","urls":["bzz-raw://fa47405ddd95fe9d5419ebaba58fb34aa621e2cf6b406e03e3e68ca407619e5d","dweb:/ipfs/QmfM4vWuiWY1iRPV2qgeqkyYiSNLAqyRoDRtvqdZyjYKcD"],"license":"MIT"}},"version":1},"ast":{"absolutePath":"src/interfaces/ILocksmith.sol","id":49658,"exportedSymbols":{"IERC1155":[45891],"IERC165":[46389],"ILocksmith":[49657],"InvalidRing":[49436],"InvalidRingKey":[49442],"InvalidRingKeySet":[49444],"KeyNotHeld":[49438],"KeyNotRoot":[49440],"SoulboundTransferBreach":[49446]},"nodeType":"SourceUnit","src":"33:13880:36","nodes":[{"id":49430,"nodeType":"PragmaDirective","src":"33:24:36","nodes":[],"literals":["solidity","^","0.8",".23"]},{"id":49432,"nodeType":"ImportDirective","src":"935:87:36","nodes":[],"absolutePath":"lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol","file":"openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol","nameLocation":"-1:-1:-1","scope":49658,"sourceUnit":45892,"symbolAliases":[{"foreign":{"id":49431,"name":"IERC1155","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":45891,"src":"944:8:36","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":49434,"nodeType":"ImportDirective","src":"1331:91:36","nodes":[],"absolutePath":"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol","file":"openzeppelin-contracts/contracts/utils/introspection/IERC165.sol","nameLocation":"-1:-1:-1","scope":49658,"sourceUnit":46390,"symbolAliases":[{"foreign":{"id":49433,"name":"IERC165","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":46389,"src":"1340:7:36","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":49436,"nodeType":"ErrorDefinition","src":"1531:20:36","nodes":[],"errorSelector":"8cfb945f","name":"InvalidRing","nameLocation":"1537:11:36","parameters":{"id":49435,"nodeType":"ParameterList","parameters":[],"src":"1548:2:36"}},{"id":49438,"nodeType":"ErrorDefinition","src":"1695:19:36","nodes":[],"errorSelector":"86f0dd27","name":"KeyNotHeld","nameLocation":"1701:10:36","parameters":{"id":49437,"nodeType":"ParameterList","parameters":[],"src":"1711:2:36"}},{"id":49440,"nodeType":"ErrorDefinition","src":"1846:19:36","nodes":[],"errorSelector":"11d118e3","name":"KeyNotRoot","nameLocation":"1852:10:36","parameters":{"id":49439,"nodeType":"ParameterList","parameters":[],"src":"1862:2:36"}},{"id":49442,"nodeType":"ErrorDefinition","src":"1997:23:36","nodes":[],"errorSelector":"3d98f00a","name":"InvalidRingKey","nameLocation":"2003:14:36","parameters":{"id":49441,"nodeType":"ParameterList","parameters":[],"src":"2017:2:36"}},{"id":49444,"nodeType":"ErrorDefinition","src":"2137:26:36","nodes":[],"errorSelector":"3e0d1016","name":"InvalidRingKeySet","nameLocation":"2143:17:36","parameters":{"id":49443,"nodeType":"ParameterList","parameters":[],"src":"2160:2:36"}},{"id":49446,"nodeType":"ErrorDefinition","src":"2282:32:36","nodes":[],"errorSelector":"ba323d8e","name":"SoulboundTransferBreach","nameLocation":"2288:23:36","parameters":{"id":49445,"nodeType":"ParameterList","parameters":[],"src":"2311:2:36"}},{"id":49657,"nodeType":"ContractDefinition","src":"3009:10903:36","nodes":[{"id":49462,"nodeType":"EventDefinition","src":"3606:92:36","nodes":[],"anonymous":false,"documentation":{"id":49452,"nodeType":"StructuredDocumentation","src":"3196:405:36","text":" keyRingCreated \n This event is emitted when a key ring is created and a root key is minted.\n @param operator  the message sender and creator of the key ring.\n @param ringId    the resulting id of the new key ring. \n @param ringName  the ring's human readable name, encoded as a bytes32.\n @param recipient the address of the root key recipient"},"eventSelector":"be0a6b08dc0f46f9b7f5f1e190db85fb39a437818404c53cc69ef01156ba26dc","name":"keyRingCreated","nameLocation":"3612:14:36","parameters":{"id":49461,"nodeType":"ParameterList","parameters":[{"constant":false,"id":49454,"indexed":false,"mutability":"mutable","name":"operator","nameLocation":"3635:8:36","nodeType":"VariableDeclaration","scope":49462,"src":"3627:16:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":49453,"name":"address","nodeType":"ElementaryTypeName","src":"3627:7:36","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":49456,"indexed":false,"mutability":"mutable","name":"ringId","nameLocation":"3653:6:36","nodeType":"VariableDeclaration","scope":49462,"src":"3645:14:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":49455,"name":"uint256","nodeType":"ElementaryTypeName","src":"3645:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":49458,"indexed":false,"mutability":"mutable","name":"ringName","nameLocation":"3669:8:36","nodeType":"VariableDeclaration","scope":49462,"src":"3661:16:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":49457,"name":"bytes32","nodeType":"ElementaryTypeName","src":"3661:7:36","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":49460,"indexed":false,"mutability":"mutable","name":"recipient","nameLocation":"3687:9:36","nodeType":"VariableDeclaration","scope":49462,"src":"3679:17:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":49459,"name":"address","nodeType":"ElementaryTypeName","src":"3679:7:36","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"3626:71:36"}},{"id":49473,"nodeType":"EventDefinition","src":"4228:83:36","nodes":[],"anonymous":false,"documentation":{"id":49463,"nodeType":"StructuredDocumentation","src":"3704:519:36","text":" keyMinted\n This event is emitted when a key is minted. This event\n is also emitted when a root key is minted upon ring creation.\n The operator will always hold the root key for the ringId.\n @param operator the creator of the ring key.\n @param ringId   the key ring ID they are creating the key on. \n @param keyId    the key ID that was minted by the operator. \n @param receiver the receiving wallet address where the keyId was deposited."},"eventSelector":"c3e4f2d50128507beb30816d311059d8c2f3c0d0fa3ae1341cfc48cece87760e","name":"keyMinted","nameLocation":"4234:9:36","parameters":{"id":49472,"nodeType":"ParameterList","parameters":[{"constant":false,"id":49465,"indexed":false,"mutability":"mutable","name":"operator","nameLocation":"4252:8:36","nodeType":"VariableDeclaration","scope":49473,"src":"4244:16:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":49464,"name":"address","nodeType":"ElementaryTypeName","src":"4244:7:36","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":49467,"indexed":false,"mutability":"mutable","name":"ringId","nameLocation":"4270:6:36","nodeType":"VariableDeclaration","scope":49473,"src":"4262:14:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":49466,"name":"uint256","nodeType":"ElementaryTypeName","src":"4262:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":49469,"indexed":false,"mutability":"mutable","name":"keyId","nameLocation":"4286:5:36","nodeType":"VariableDeclaration","scope":49473,"src":"4278:13:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":49468,"name":"uint256","nodeType":"ElementaryTypeName","src":"4278:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":49471,"indexed":false,"mutability":"mutable","name":"receiver","nameLocation":"4301:8:36","nodeType":"VariableDeclaration","scope":49473,"src":"4293:16:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":49470,"name":"address","nodeType":"ElementaryTypeName","src":"4293:7:36","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"4243:67:36"}},{"id":49486,"nodeType":"EventDefinition","src":"4764:97:36","nodes":[],"anonymous":false,"documentation":{"id":49474,"nodeType":"StructuredDocumentation","src":"4321:438:36","text":" keyBurned\n This event is emitted when a key is burned by the root key\n holder. \n @param operator the root key holder requesting the burn. \n @param ringId   the ring ID they are burning from.\n @param keyId    the key ID that was burned. \n @param target   the address of the wallet that had keys burned. \n @param amount   the number of keys burned in the operation."},"eventSelector":"707b83adf4af3b12b746160986598d56e5b5d926ad0a6ce43d49c35bb77b5856","name":"keyBurned","nameLocation":"4770:9:36","parameters":{"id":49485,"nodeType":"ParameterList","parameters":[{"constant":false,"id":49476,"indexed":false,"mutability":"mutable","name":"operator","nameLocation":"4788:8:36","nodeType":"VariableDeclaration","scope":49486,"src":"4780:16:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":49475,"name":"address","nodeType":"ElementaryTypeName","src":"4780:7:36","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":49478,"indexed":false,"mutability":"mutable","name":"ringId","nameLocation":"4806:6:36","nodeType":"VariableDeclaration","scope":49486,"src":"4798:14:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":49477,"name":"uint256","nodeType":"ElementaryTypeName","src":"4798:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":49480,"indexed":false,"mutability":"mutable","name":"keyId","nameLocation":"4822:5:36","nodeType":"VariableDeclaration","scope":49486,"src":"4814:13:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":49479,"name":"uint256","nodeType":"ElementaryTypeName","src":"4814:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":49482,"indexed":false,"mutability":"mutable","name":"target","nameLocation":"4837:6:36","nodeType":"VariableDeclaration","scope":49486,"src":"4829:14:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":49481,"name":"address","nodeType":"ElementaryTypeName","src":"4829:7:36","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":49484,"indexed":false,"mutability":"mutable","name":"amount","nameLocation":"4853:6:36","nodeType":"VariableDeclaration","scope":49486,"src":"4845:14:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":49483,"name":"uint256","nodeType":"ElementaryTypeName","src":"4845:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"4779:81:36"}},{"id":49497,"nodeType":"EventDefinition","src":"5273:96:36","nodes":[],"anonymous":false,"documentation":{"id":49487,"nodeType":"StructuredDocumentation","src":"4867:401:36","text":" setSoulboundKeyAmount\n This event fires when the state of a soulbind key is set.\n @param operator  the root key holder that is changing the soulbinding \n @param keyHolder the address we are changing the binding for\n @param keyId     the Id we are setting the binding state for\n @param amount    the number of tokens this address must hold"},"eventSelector":"dd4ed73814d490cf0c19636b7b143543516fb68cc7d4fff60b44805e18913f44","name":"setSoulboundKeyAmount","nameLocation":"5279:21:36","parameters":{"id":49496,"nodeType":"ParameterList","parameters":[{"constant":false,"id":49489,"indexed":false,"mutability":"mutable","name":"operator","nameLocation":"5309:8:36","nodeType":"VariableDeclaration","scope":49497,"src":"5301:16:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":49488,"name":"address","nodeType":"ElementaryTypeName","src":"5301:7:36","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":49491,"indexed":false,"mutability":"mutable","name":"keyHolder","nameLocation":"5327:9:36","nodeType":"VariableDeclaration","scope":49497,"src":"5319:17:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":49490,"name":"address","nodeType":"ElementaryTypeName","src":"5319:7:36","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":49493,"indexed":false,"mutability":"mutable","name":"keyId","nameLocation":"5346:5:36","nodeType":"VariableDeclaration","scope":49497,"src":"5338:13:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":49492,"name":"uint256","nodeType":"ElementaryTypeName","src":"5338:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":49495,"indexed":false,"mutability":"mutable","name":"amount","nameLocation":"5361:6:36","nodeType":"VariableDeclaration","scope":49497,"src":"5353:14:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":49494,"name":"uint256","nodeType":"ElementaryTypeName","src":"5353:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"5300:68:36"}},{"id":49513,"nodeType":"FunctionDefinition","src":"6120:141:36","nodes":[],"documentation":{"id":49498,"nodeType":"StructuredDocumentation","src":"5523:595:36","text":" createKeyRing\n Calling this function will create a key ring with a name,\n mint the first root key, and give it to the desginated receiver.\n @param ringName    A string defining the name of the key ring encoded as bytes32.\n @param rootKeyName A string denoting a human readable name of the root key. \n @param keyUri      The metadata URI for the new root key.\n @param recipient   The address to receive the root key for this key ring.\n @return the key ring ID that was created\n @return the root key ID that was created"},"functionSelector":"f01bda63","implemented":false,"kind":"function","modifiers":[],"name":"createKeyRing","nameLocation":"6129:13:36","parameters":{"id":49507,"nodeType":"ParameterList","parameters":[{"constant":false,"id":49500,"mutability":"mutable","name":"ringName","nameLocation":"6151:8:36","nodeType":"VariableDeclaration","scope":49513,"src":"6143:16:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":49499,"name":"bytes32","nodeType":"ElementaryTypeName","src":"6143:7:36","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":49502,"mutability":"mutable","name":"rootKeyName","nameLocation":"6169:11:36","nodeType":"VariableDeclaration","scope":49513,"src":"6161:19:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":49501,"name":"bytes32","nodeType":"ElementaryTypeName","src":"6161:7:36","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":49504,"mutability":"mutable","name":"keyUri","nameLocation":"6198:6:36","nodeType":"VariableDeclaration","scope":49513,"src":"6182:22:36","stateVariable":false,"storageLocation":"calldata","typeDescriptions":{"typeIdentifier":"t_string_calldata_ptr","typeString":"string"},"typeName":{"id":49503,"name":"string","nodeType":"ElementaryTypeName","src":"6182:6:36","typeDescriptions":{"typeIdentifier":"t_string_storage_ptr","typeString":"string"}},"visibility":"internal"},{"constant":false,"id":49506,"mutability":"mutable","name":"recipient","nameLocation":"6214:9:36","nodeType":"VariableDeclaration","scope":49513,"src":"6206:17:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":49505,"name":"address","nodeType":"ElementaryTypeName","src":"6206:7:36","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"6142:82:36"},"returnParameters":{"id":49512,"nodeType":"ParameterList","parameters":[{"constant":false,"id":49509,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":49513,"src":"6243:7:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":49508,"name":"uint256","nodeType":"ElementaryTypeName","src":"6243:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":49511,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":49513,"src":"6252:7:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":49510,"name":"uint256","nodeType":"ElementaryTypeName","src":"6252:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"6242:18:36"},"scope":49657,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":49529,"nodeType":"FunctionDefinition","src":"6993:135:36","nodes":[],"documentation":{"id":49514,"nodeType":"StructuredDocumentation","src":"6272:716:36","text":" createKey\n The holder of a root key can use it to generate brand new keys \n and add them to the root key's key ring, sending it to the \n destination wallets.\n This code will panic if:\n  - the caller doesn't hold the declared root key\n @param rootKeyId The root key the sender is attempting to operate to create new keys.\n @param keyName   An alias that you want to give the key.\n @param keyUri    The metadata URI for the newly created key.\n @param receiver  address you want to receive the ring key. \n @param bind      true if you want to bind the key to the receiver.\n @return the ID of the key that was created"},"functionSelector":"18c28027","implemented":false,"kind":"function","modifiers":[],"name":"createKey","nameLocation":"7002:9:36","parameters":{"id":49525,"nodeType":"ParameterList","parameters":[{"constant":false,"id":49516,"mutability":"mutable","name":"rootKeyId","nameLocation":"7020:9:36","nodeType":"VariableDeclaration","scope":49529,"src":"7012:17:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":49515,"name":"uint256","nodeType":"ElementaryTypeName","src":"7012:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":49518,"mutability":"mutable","name":"keyName","nameLocation":"7039:7:36","nodeType":"VariableDeclaration","scope":49529,"src":"7031:15:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":49517,"name":"bytes32","nodeType":"ElementaryTypeName","src":"7031:7:36","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":49520,"mutability":"mutable","name":"keyUri","nameLocation":"7064:6:36","nodeType":"VariableDeclaration","scope":49529,"src":"7048:22:36","stateVariable":false,"storageLocation":"calldata","typeDescriptions":{"typeIdentifier":"t_string_calldata_ptr","typeString":"string"},"typeName":{"id":49519,"name":"string","nodeType":"ElementaryTypeName","src":"7048:6:36","typeDescriptions":{"typeIdentifier":"t_string_storage_ptr","typeString":"string"}},"visibility":"internal"},{"constant":false,"id":49522,"mutability":"mutable","name":"receiver","nameLocation":"7080:8:36","nodeType":"VariableDeclaration","scope":49529,"src":"7072:16:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":49521,"name":"address","nodeType":"ElementaryTypeName","src":"7072:7:36","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":49524,"mutability":"mutable","name":"bind","nameLocation":"7095:4:36","nodeType":"VariableDeclaration","scope":49529,"src":"7090:9:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":49523,"name":"bool","nodeType":"ElementaryTypeName","src":"7090:4:36","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"}],"src":"7011:89:36"},"returnParameters":{"id":49528,"nodeType":"ParameterList","parameters":[{"constant":false,"id":49527,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":49529,"src":"7119:7:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":49526,"name":"uint256","nodeType":"ElementaryTypeName","src":"7119:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"7118:9:36"},"scope":49657,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":49541,"nodeType":"FunctionDefinition","src":"8134:89:36","nodes":[],"documentation":{"id":49530,"nodeType":"StructuredDocumentation","src":"7139:990:36","text":" copyKey\n The root key holder can call this method if they have an existing key\n they want to copy. This allows multiple addresses to hold the same role,\n share a set of benefits, or enables the root key holder to restore\n the role for someone who lost their seed or access to their wallet.\n This method can only be invoked with a root key, which is held by\n the message sender. The key they want to copy also must be associated\n with the ring bound to the root key used.\n This code will panic if:\n  - the caller doesn't hold the root key\n  - the provided key ID isn't associated with the root key's key ring\n @param rootKeyId root key to be used for this operation.\n @param keyId     key ID the message sender wishes to copy.\n @param receiver  addresses of the receivers for the copied key.\n @param bind      true if you want to bind the key to the receiver. "},"functionSelector":"218fa8e6","implemented":false,"kind":"function","modifiers":[],"name":"copyKey","nameLocation":"8143:7:36","parameters":{"id":49539,"nodeType":"ParameterList","parameters":[{"constant":false,"id":49532,"mutability":"mutable","name":"rootKeyId","nameLocation":"8159:9:36","nodeType":"VariableDeclaration","scope":49541,"src":"8151:17:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":49531,"name":"uint256","nodeType":"ElementaryTypeName","src":"8151:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":49534,"mutability":"mutable","name":"keyId","nameLocation":"8178:5:36","nodeType":"VariableDeclaration","scope":49541,"src":"8170:13:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":49533,"name":"uint256","nodeType":"ElementaryTypeName","src":"8170:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":49536,"mutability":"mutable","name":"receiver","nameLocation":"8193:8:36","nodeType":"VariableDeclaration","scope":49541,"src":"8185:16:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":49535,"name":"address","nodeType":"ElementaryTypeName","src":"8185:7:36","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":49538,"mutability":"mutable","name":"bind","nameLocation":"8208:4:36","nodeType":"VariableDeclaration","scope":49541,"src":"8203:9:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":49537,"name":"bool","nodeType":"ElementaryTypeName","src":"8203:4:36","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"}],"src":"8150:63:36"},"returnParameters":{"id":49540,"nodeType":"ParameterList","parameters":[],"src":"8222:0:36"},"scope":49657,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":49553,"nodeType":"FunctionDefinition","src":"8989:99:36","nodes":[],"documentation":{"id":49542,"nodeType":"StructuredDocumentation","src":"8233:751:36","text":" soulbindKey\n This method can be called by a root key holder to make a key\n soulbound to a specific address. When soulbinding a key,\n it is not required that the current target address hold that key.\n The amount set ensures that when sending a key of a specific\n type, that they hold at least the amount that is bound to them.\n This code will panic if:\n  - the caller doesn't have the root key\n  - the target keyId doesn't exist in the ring\n @param rootKeyId the operator's root key.\n @param keyHolder the address to bind the key to.\n @param keyId     the keyId they want to bind.\n @param amount    the amount of keys to bind to the holder."},"functionSelector":"6d7012fa","implemented":false,"kind":"function","modifiers":[],"name":"soulbindKey","nameLocation":"8998:11:36","parameters":{"id":49551,"nodeType":"ParameterList","parameters":[{"constant":false,"id":49544,"mutability":"mutable","name":"rootKeyId","nameLocation":"9018:9:36","nodeType":"VariableDeclaration","scope":49553,"src":"9010:17:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":49543,"name":"uint256","nodeType":"ElementaryTypeName","src":"9010:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":49546,"mutability":"mutable","name":"keyHolder","nameLocation":"9037:9:36","nodeType":"VariableDeclaration","scope":49553,"src":"9029:17:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":49545,"name":"address","nodeType":"ElementaryTypeName","src":"9029:7:36","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":49548,"mutability":"mutable","name":"keyId","nameLocation":"9056:5:36","nodeType":"VariableDeclaration","scope":49553,"src":"9048:13:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":49547,"name":"uint256","nodeType":"ElementaryTypeName","src":"9048:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":49550,"mutability":"mutable","name":"amount","nameLocation":"9071:6:36","nodeType":"VariableDeclaration","scope":49553,"src":"9063:14:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":49549,"name":"uint256","nodeType":"ElementaryTypeName","src":"9063:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"9009:69:36"},"returnParameters":{"id":49552,"nodeType":"ParameterList","parameters":[],"src":"9087:0:36"},"scope":49657,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":49565,"nodeType":"FunctionDefinition","src":"9697:92:36","nodes":[],"documentation":{"id":49554,"nodeType":"StructuredDocumentation","src":"9094:598:36","text":" burnKey\n The root key holder can call this method if they want to revoke\n a key from a holder.\n This code will panic if:\n  - The caller doesn't hold the root key.\n  - The key id is not on the same ring as the root key.\n  - The target holder doesn't have sufficient keys to burn.\n @param rootKeyId root key for the associated ring.\n @param keyId     id of the key you want to burn.\n @param holder    address of the holder you want to burn from.\n @param amount    the number of keys you want to burn."},"functionSelector":"11511668","implemented":false,"kind":"function","modifiers":[],"name":"burnKey","nameLocation":"9706:7:36","parameters":{"id":49563,"nodeType":"ParameterList","parameters":[{"constant":false,"id":49556,"mutability":"mutable","name":"rootKeyId","nameLocation":"9722:9:36","nodeType":"VariableDeclaration","scope":49565,"src":"9714:17:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":49555,"name":"uint256","nodeType":"ElementaryTypeName","src":"9714:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":49558,"mutability":"mutable","name":"keyId","nameLocation":"9741:5:36","nodeType":"VariableDeclaration","scope":49565,"src":"9733:13:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":49557,"name":"uint256","nodeType":"ElementaryTypeName","src":"9733:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":49560,"mutability":"mutable","name":"holder","nameLocation":"9756:6:36","nodeType":"VariableDeclaration","scope":49565,"src":"9748:14:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":49559,"name":"address","nodeType":"ElementaryTypeName","src":"9748:7:36","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":49562,"mutability":"mutable","name":"amount","nameLocation":"9772:6:36","nodeType":"VariableDeclaration","scope":49565,"src":"9764:14:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":49561,"name":"uint256","nodeType":"ElementaryTypeName","src":"9764:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"9713:66:36"},"returnParameters":{"id":49564,"nodeType":"ParameterList","parameters":[],"src":"9788:0:36"},"scope":49657,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":49580,"nodeType":"FunctionDefinition","src":"10285:105:36","nodes":[],"documentation":{"id":49566,"nodeType":"StructuredDocumentation","src":"9939:341:36","text":" getRingInfo()\n Given a ring, provides ring metadata back.\n @param ringId The ID of the ring to inspect.\n @return The ring ID back as verification.\n @return The human readable name for the ring.\n @return The root key ID for the ring.\n @return The list of keys for the ring."},"functionSelector":"4dfdf2c8","implemented":false,"kind":"function","modifiers":[],"name":"getRingInfo","nameLocation":"10294:11:36","parameters":{"id":49569,"nodeType":"ParameterList","parameters":[{"constant":false,"id":49568,"mutability":"mutable","name":"ringId","nameLocation":"10314:6:36","nodeType":"VariableDeclaration","scope":49580,"src":"10306:14:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":49567,"name":"uint256","nodeType":"ElementaryTypeName","src":"10306:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"10305:16:36"},"returnParameters":{"id":49579,"nodeType":"ParameterList","parameters":[{"constant":false,"id":49571,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":49580,"src":"10345:7:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":49570,"name":"uint256","nodeType":"ElementaryTypeName","src":"10345:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":49573,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":49580,"src":"10354:7:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":49572,"name":"bytes32","nodeType":"ElementaryTypeName","src":"10354:7:36","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":49575,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":49580,"src":"10363:7:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":49574,"name":"uint256","nodeType":"ElementaryTypeName","src":"10363:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":49578,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":49580,"src":"10372:16:36","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_memory_ptr","typeString":"uint256[]"},"typeName":{"baseType":{"id":49576,"name":"uint256","nodeType":"ElementaryTypeName","src":"10372:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":49577,"nodeType":"ArrayTypeName","src":"10372:9:36","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_storage_ptr","typeString":"uint256[]"}},"visibility":"internal"}],"src":"10344:45:36"},"scope":49657,"stateMutability":"view","virtual":false,"visibility":"external"},{"id":49589,"nodeType":"FunctionDefinition","src":"10654:83:36","nodes":[],"documentation":{"id":49581,"nodeType":"StructuredDocumentation","src":"10393:256:36","text":" getKeysForHolder\n This method will return the IDs of the keys held\n by the given address.\n @param  holder the address of the key holder you want to see.\n @return an array of key IDs held by the user."},"functionSelector":"039cf5fb","implemented":false,"kind":"function","modifiers":[],"name":"getKeysForHolder","nameLocation":"10663:16:36","parameters":{"id":49584,"nodeType":"ParameterList","parameters":[{"constant":false,"id":49583,"mutability":"mutable","name":"holder","nameLocation":"10688:6:36","nodeType":"VariableDeclaration","scope":49589,"src":"10680:14:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":49582,"name":"address","nodeType":"ElementaryTypeName","src":"10680:7:36","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"10679:16:36"},"returnParameters":{"id":49588,"nodeType":"ParameterList","parameters":[{"constant":false,"id":49587,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":49589,"src":"10719:16:36","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_memory_ptr","typeString":"uint256[]"},"typeName":{"baseType":{"id":49585,"name":"uint256","nodeType":"ElementaryTypeName","src":"10719:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":49586,"nodeType":"ArrayTypeName","src":"10719:9:36","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_storage_ptr","typeString":"uint256[]"}},"visibility":"internal"}],"src":"10718:18:36"},"scope":49657,"stateMutability":"view","virtual":false,"visibility":"external"},{"id":49598,"nodeType":"FunctionDefinition","src":"10972:76:36","nodes":[],"documentation":{"id":49590,"nodeType":"StructuredDocumentation","src":"10740:227:36","text":" getHolders\n This method will return the addresses that hold\n a particular keyId.\n @param  keyId the key ID to look for.\n @return an array of addresses that hold that key."},"functionSelector":"92707869","implemented":false,"kind":"function","modifiers":[],"name":"getHolders","nameLocation":"10981:10:36","parameters":{"id":49593,"nodeType":"ParameterList","parameters":[{"constant":false,"id":49592,"mutability":"mutable","name":"keyId","nameLocation":"11000:5:36","nodeType":"VariableDeclaration","scope":49598,"src":"10992:13:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":49591,"name":"uint256","nodeType":"ElementaryTypeName","src":"10992:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"10991:15:36"},"returnParameters":{"id":49597,"nodeType":"ParameterList","parameters":[{"constant":false,"id":49596,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":49598,"src":"11030:16:36","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_address_$dyn_memory_ptr","typeString":"address[]"},"typeName":{"baseType":{"id":49594,"name":"address","nodeType":"ElementaryTypeName","src":"11030:7:36","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"id":49595,"nodeType":"ArrayTypeName","src":"11030:9:36","typeDescriptions":{"typeIdentifier":"t_array$_t_address_$dyn_storage_ptr","typeString":"address[]"}},"visibility":"internal"}],"src":"11029:18:36"},"scope":49657,"stateMutability":"view","virtual":false,"visibility":"external"},{"id":49608,"nodeType":"FunctionDefinition","src":"11452:92:36","nodes":[],"documentation":{"id":49599,"nodeType":"StructuredDocumentation","src":"11051:396:36","text":" getSoulboundAmount \n Returns the number of keys a given holder must maintain when\n sending the associated key ID out of their address.\n @param account   The wallet address you want the binding amount for. \n @param keyId     The key id you want the soulbound amount for. \n @return the soulbound token requirement for that wallet and key id."},"functionSelector":"102e6c66","implemented":false,"kind":"function","modifiers":[],"name":"getSoulboundAmount","nameLocation":"11461:18:36","parameters":{"id":49604,"nodeType":"ParameterList","parameters":[{"constant":false,"id":49601,"mutability":"mutable","name":"account","nameLocation":"11488:7:36","nodeType":"VariableDeclaration","scope":49608,"src":"11480:15:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":49600,"name":"address","nodeType":"ElementaryTypeName","src":"11480:7:36","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":49603,"mutability":"mutable","name":"keyId","nameLocation":"11505:5:36","nodeType":"VariableDeclaration","scope":49608,"src":"11497:13:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":49602,"name":"uint256","nodeType":"ElementaryTypeName","src":"11497:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"11479:32:36"},"returnParameters":{"id":49607,"nodeType":"ParameterList","parameters":[{"constant":false,"id":49606,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":49608,"src":"11535:7:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":49605,"name":"uint256","nodeType":"ElementaryTypeName","src":"11535:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"11534:9:36"},"scope":49657,"stateMutability":"view","virtual":false,"visibility":"external"},{"id":49616,"nodeType":"FunctionDefinition","src":"11712:62:36","nodes":[],"documentation":{"id":49609,"nodeType":"StructuredDocumentation","src":"11550:157:36","text":" isRootKey\n @param keyId the key id in question\n @return true if the key Id is the root key of it's associated key ring "},"functionSelector":"d2bd0fad","implemented":false,"kind":"function","modifiers":[],"name":"isRootKey","nameLocation":"11721:9:36","parameters":{"id":49612,"nodeType":"ParameterList","parameters":[{"constant":false,"id":49611,"mutability":"mutable","name":"keyId","nameLocation":"11739:5:36","nodeType":"VariableDeclaration","scope":49616,"src":"11731:13:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":49610,"name":"uint256","nodeType":"ElementaryTypeName","src":"11731:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"11730:15:36"},"returnParameters":{"id":49615,"nodeType":"ParameterList","parameters":[{"constant":false,"id":49614,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":49616,"src":"11768:4:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":49613,"name":"bool","nodeType":"ElementaryTypeName","src":"11768:4:36","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"}],"src":"11767:6:36"},"scope":49657,"stateMutability":"view","virtual":false,"visibility":"external"},{"id":49633,"nodeType":"FunctionDefinition","src":"12125:106:36","nodes":[],"documentation":{"id":49617,"nodeType":"StructuredDocumentation","src":"11785:334:36","text":" inspectKey \n \n Takes a key id and inspects it.\n \n @return true if the key is a valid key\n @return alias of the key \n @return the ring id of the key (only if its considered valid)\n @return true if the key is a root key\n @return the keys associated with the given ring "},"functionSelector":"88ecda52","implemented":false,"kind":"function","modifiers":[],"name":"inspectKey","nameLocation":"12134:10:36","parameters":{"id":49620,"nodeType":"ParameterList","parameters":[{"constant":false,"id":49619,"mutability":"mutable","name":"keyId","nameLocation":"12153:5:36","nodeType":"VariableDeclaration","scope":49633,"src":"12145:13:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":49618,"name":"uint256","nodeType":"ElementaryTypeName","src":"12145:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"12144:15:36"},"returnParameters":{"id":49632,"nodeType":"ParameterList","parameters":[{"constant":false,"id":49622,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":49633,"src":"12183:4:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":49621,"name":"bool","nodeType":"ElementaryTypeName","src":"12183:4:36","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"},{"constant":false,"id":49624,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":49633,"src":"12189:7:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":49623,"name":"bytes32","nodeType":"ElementaryTypeName","src":"12189:7:36","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":49626,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":49633,"src":"12198:7:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":49625,"name":"uint256","nodeType":"ElementaryTypeName","src":"12198:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":49628,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":49633,"src":"12207:4:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":49627,"name":"bool","nodeType":"ElementaryTypeName","src":"12207:4:36","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"},{"constant":false,"id":49631,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":49633,"src":"12213:16:36","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_memory_ptr","typeString":"uint256[]"},"typeName":{"baseType":{"id":49629,"name":"uint256","nodeType":"ElementaryTypeName","src":"12213:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":49630,"nodeType":"ArrayTypeName","src":"12213:9:36","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_storage_ptr","typeString":"uint256[]"}},"visibility":"internal"}],"src":"12182:48:36"},"scope":49657,"stateMutability":"view","virtual":false,"visibility":"external"},{"id":49643,"nodeType":"FunctionDefinition","src":"12779:85:36","nodes":[],"documentation":{"id":49634,"nodeType":"StructuredDocumentation","src":"12237:537:36","text":" hasKeyOrRoot\n Determines if the given address holders either the key specified,\n or the ring's root key.\n This is used by contracts to enable root-key escalation,\n and prevents the need for root key holders to hold every key to\n operate as an admin.\n @param keyHolder the address of the keyholder to check.\n @param keyId     the key you want to check they are holding.\n @return true if keyHolder has either keyId, or the keyId's associated root key."},"functionSelector":"02dcd8c1","implemented":false,"kind":"function","modifiers":[],"name":"hasKeyOrRoot","nameLocation":"12788:12:36","parameters":{"id":49639,"nodeType":"ParameterList","parameters":[{"constant":false,"id":49636,"mutability":"mutable","name":"keyHolder","nameLocation":"12809:9:36","nodeType":"VariableDeclaration","scope":49643,"src":"12801:17:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":49635,"name":"address","nodeType":"ElementaryTypeName","src":"12801:7:36","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":49638,"mutability":"mutable","name":"keyId","nameLocation":"12828:5:36","nodeType":"VariableDeclaration","scope":49643,"src":"12820:13:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":49637,"name":"uint256","nodeType":"ElementaryTypeName","src":"12820:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"12800:34:36"},"returnParameters":{"id":49642,"nodeType":"ParameterList","parameters":[{"constant":false,"id":49641,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":49643,"src":"12858:4:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":49640,"name":"bool","nodeType":"ElementaryTypeName","src":"12858:4:36","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"}],"src":"12857:6:36"},"scope":49657,"stateMutability":"view","virtual":false,"visibility":"external"},{"id":49656,"nodeType":"FunctionDefinition","src":"13799:111:36","nodes":[],"documentation":{"id":49644,"nodeType":"StructuredDocumentation","src":"12870:924:36","text":" validateKeyRing\n Contracts can call this method to determine if a set\n of keys belong to the same ring. This is used as a validation\n method and will *revert* if the keys do not belong to the same\n ring. This is extremely useful when taking a set of keys and ensuring\n each is part of the same ring first.\n You can use allowRoot to enable cases were passing in the root key\n for validation is acceptable. Setting it to false enables you\n to easily detect if one of the keys provided is the root key.\n Remember, this method will revert also based on allowRoot semantics. \n @param ringId    the ring ID you want to validate against\n @param keys      the supposed keys that belong to the ring\n @param allowRoot true if providing the ring's root key as input is acceptable\n @return true if valid, or will otherwise revert."},"functionSelector":"53a81ee1","implemented":false,"kind":"function","modifiers":[],"name":"validateKeyRing","nameLocation":"13808:15:36","parameters":{"id":49652,"nodeType":"ParameterList","parameters":[{"constant":false,"id":49646,"mutability":"mutable","name":"ringId","nameLocation":"13832:6:36","nodeType":"VariableDeclaration","scope":49656,"src":"13824:14:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":49645,"name":"uint256","nodeType":"ElementaryTypeName","src":"13824:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":49649,"mutability":"mutable","name":"keys","nameLocation":"13859:4:36","nodeType":"VariableDeclaration","scope":49656,"src":"13840:23:36","stateVariable":false,"storageLocation":"calldata","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_calldata_ptr","typeString":"uint256[]"},"typeName":{"baseType":{"id":49647,"name":"uint256","nodeType":"ElementaryTypeName","src":"13840:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":49648,"nodeType":"ArrayTypeName","src":"13840:9:36","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_storage_ptr","typeString":"uint256[]"}},"visibility":"internal"},{"constant":false,"id":49651,"mutability":"mutable","name":"allowRoot","nameLocation":"13870:9:36","nodeType":"VariableDeclaration","scope":49656,"src":"13865:14:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":49650,"name":"bool","nodeType":"ElementaryTypeName","src":"13865:4:36","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"}],"src":"13823:57:36"},"returnParameters":{"id":49655,"nodeType":"ParameterList","parameters":[{"constant":false,"id":49654,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":49656,"src":"13904:4:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":49653,"name":"bool","nodeType":"ElementaryTypeName","src":"13904:4:36","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"}],"src":"13903:6:36"},"scope":49657,"stateMutability":"view","virtual":false,"visibility":"external"}],"abstract":false,"baseContracts":[{"baseName":{"id":49448,"name":"IERC165","nameLocations":["3033:7:36"],"nodeType":"IdentifierPath","referencedDeclaration":46389,"src":"3033:7:36"},"id":49449,"nodeType":"InheritanceSpecifier","src":"3033:7:36"},{"baseName":{"id":49450,"name":"IERC1155","nameLocations":["3042:8:36"],"nodeType":"IdentifierPath","referencedDeclaration":45891,"src":"3042:8:36"},"id":49451,"nodeType":"InheritanceSpecifier","src":"3042:8:36"}],"canonicalName":"ILocksmith","contractDependencies":[],"contractKind":"interface","documentation":{"id":49447,"nodeType":"StructuredDocumentation","src":"2316:692:36","text":" Locksmith \n This contract has a single responsiblity: managing the lifecycle of keys.\n The Locksmith is an ERC1155 contract that can mint, burn, and bind permissions\n to owners.\n Users can permissionlessly mint and manage a collection of NFTs known as\n a \"key ring.\" Each key ring has a root key, which gives the holder permissions\n to mint, burn, and soulbind/unbind any other key that belongs to their\n ring to any address at any time.\n In effect, the key ring acts as an onchain access control list. The keys\n can be sent, delegated, and dynamically bound to any actor for any amount of\n time - including only for a part of a single transaction.\n "},"fullyImplemented":false,"linearizedBaseContracts":[49657,45891,46389],"name":"ILocksmith","nameLocation":"3019:10:36","scope":49658,"usedErrors":[],"usedEvents":[45788,45803,45812,45819,49462,49473,49486,49497]}],"license":"MIT"},"id":36}